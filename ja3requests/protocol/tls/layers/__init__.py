import os
import time
import struct
from abc import ABC, abstractmethod


class Random:
    """
    struct {
        uint32 gmt_unix_time;
        opaque random_bytes[28];
    } Random

    gmt_unix_time
         The current time and date in standard UNIX 32-bit format
         (seconds since the midnight starting Jan 1, 1970, UTC, ignoring
         leap seconds) according to the sender's internal clock.  Clocks
         are not required to be set correctly by the basic TLS protocol;
         higher-level or application protocols may define additional
         requirements.  Note that, for historical reasons, the data
         element is named using GMT, the predecessor of the current
         worldwide time base, UTC.

    random_bytes
        28 bytes generated by a secure random number generator.
    """

    def __init__(self):
        self.gmt_unix_time = self.get_unix_time()
        self.random_bytes = os.urandom(28)

    def __bytes__(self):
        return self.bytes()

    def bytes(self):
        if self.gmt_unix_time and self.random_bytes:
            return self.gmt_unix_time.to_bytes(4, byteorder="big") + self.random_bytes
        else:
            return os.urandom(32)

    @staticmethod
    def get_unix_time():

        current_time_unix = int(time.time())
        current_time_unix_32bit = current_time_unix % (2 ** 32)

        return current_time_unix_32bit


class HandShake(ABC):
    """
        enum {
            hello_request(0), client_hello(1), server_hello(2),
            certificate(11), server_key_exchange (12),
            certificate_request(13), server_hello_done(14),
            certificate_verify(15), client_key_exchange(16),
            finished(20)
            (255)
        } HandshakeType;

        struct {
            HandshakeType msg_type;
            uint24 length;
            select (HandshakeType) {
                case hello_request:         HelloRequest;
                case client_hello:          ClientHello;
                case server_hello:          ServerHello;
                case certificate:            Certificate;
                case server_key_exchange:   ServerKeyExchange;
                case certificate_request:    CertificateRequest;
                case server_hello_done:     ServerHelloDone;
                case certificate_verify:     CertificateVerify;
                case client_key_exchange:   ClientKeyExchange;
                case finished:               Finished;
            } body;
        } Handshake;

        The ClientHello message includes a random structure, which is used later in the protocol.

        opaque SessionID<0..32>;
        uint8 CipherSuite[2];    /* Cryptographic suite selector */
        enum { null(0), (255) } CompressionMethod;

        struct {
            ExtensionType extension_type;
            opaque extension_data<0..2^16-1>;
        } Extension;

        enum {
            signature_algorithms(13), (65535)
        } ExtensionType;
        -  "extension_type" identifies the particular extension type.
        -  "extension_data" contains information specific to the particular extension type.

        struct {
            uint8 major;
            uint8 minor;
        } ProtocolVersion;

        ProtocolVersion version = { 3, 2 };     /* TLS v1.1*/
        ProtocolVersion version = { 3, 3 };     /* TLS v1.2*/

        struct {
            ProtocolVersion client_version;
            Random random;
            SessionID session_id;
            CipherSuite cipher_suites<2..2^16-2>;
            CompressionMethod compression_methods<1..2^8-1>;
            select (extensions_present) {
                case false:
                    struct {};
                case true:
                    Extension extensions<0..2^16-1>;
            };
        } ClientHello;

        cipher_suites
            This is a list of the cryptographic options supported by the
            client, with the client's first preference first.  If the
            session_id field is not empty (implying a session resumption
            request), this vector MUST include at least the cipher_suite from
            that session.

            A cipher suite defines a cipher specification supported in TLS
            Version 1.2.
                CipherSuite TLS_NULL_WITH_NULL_NULL               = { 0x00,0x00 };

            The following CipherSuite definitions require that the server provide
            an RSA certificate that can be used for key exchange.  The server may
            request any signature-capable certificate in the certificate request
            message.
                CipherSuite TLS_RSA_WITH_NULL_MD5                 = { 0x00,0x01 };
                CipherSuite TLS_RSA_WITH_NULL_SHA                 = { 0x00,0x02 };
                CipherSuite TLS_RSA_WITH_NULL_SHA256              = { 0x00,0x3B };
                CipherSuite TLS_RSA_WITH_RC4_128_MD5              = { 0x00,0x04 };
                CipherSuite TLS_RSA_WITH_RC4_128_SHA              = { 0x00,0x05 };
                CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA         = { 0x00,0x0A };
                CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA          = { 0x00,0x2F };
                CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA          = { 0x00,0x35 };
                CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256       = { 0x00,0x3C };
                CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256       = { 0x00,0x3D };

            The following cipher suite definitions are used for server-
            authenticated (and optionally client-authenticated) Diffie-Hellman.
            DH denotes cipher suites in which the server's certificate contains
            the Diffie-Hellman parameters signed by the certificate authority
            (CA).  DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman
            parameters are signed by a signature-capable certificate, which has
            been signed by the CA.  The signing algorithm used by the server is
            specified after the DHE component of the CipherSuite name.  The
            server can request any signature-capable certificate from the client
            for client authentication, or it may request a Diffie-Hellman
            certificate.  Any Diffie-Hellman certificate provided by the client
            must use the parameters (group and generator) described by the
            server.
                CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x0D };
                CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x10 };
                CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x13 };
                CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x16 };
                CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA       = { 0x00,0x30 };
                CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA       = { 0x00,0x31 };
                CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA      = { 0x00,0x32 };
                CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA      = { 0x00,0x33 };
                CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA       = { 0x00,0x36 };
                CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA       = { 0x00,0x37 };
                CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA      = { 0x00,0x38 };
                CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA      = { 0x00,0x39 };
                CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256    = { 0x00,0x3E };
                CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256    = { 0x00,0x3F };
                CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256   = { 0x00,0x40 };
                CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256   = { 0x00,0x67 };
                CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256    = { 0x00,0x68 };
                CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256    = { 0x00,0x69 };
                CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256   = { 0x00,0x6A };
                CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256   = { 0x00,0x6B };

            The following cipher suites are used for completely anonymous
            Diffie-Hellman communications in which neither party is
            authenticated.  Note that this mode is vulnerable to man-in-the-
            middle attacks.  Using this mode therefore is of limited use: These
            cipher suites MUST NOT be used by TLS 1.2 implementations unless the
            application layer has specifically requested to allow anonymous key
            exchange.  (Anonymous key exchange may sometimes be acceptable, for
            example, to support opportunistic encryption when no set-up for
            authentication is in place, or when TLS is used as part of more
            complex security protocols that have other means to ensure
            authentication.)
                CipherSuite TLS_DH_anon_WITH_RC4_128_MD5          = { 0x00,0x18 };
                CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x1B };
                CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA      = { 0x00,0x34 };
                CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA      = { 0x00,0x3A };
                CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256   = { 0x00,0x6C };
                CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256   = { 0x00,0x6D };

            Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are
            reserved to avoid collision with Fortezza-based cipher suites in
            SSL 3.
        """

    def __init__(self):
        self._version = None
        self._random = None
        self._session_id = None
        self._cipher_suites = None
        self._compression_methods = None
        self._extensions = None

    def __len__(self):

        return self.length()

    @property
    @abstractmethod
    def handshake_type(self) -> bytes:

        raise NotImplementedError("handshake_type method must be implemented by subclass.")

    @property
    def version(self) -> bytes:
        """
        client_version
            The version of the TLS protocol by which the client wishes to
            communicate during this session.  This SHOULD be the latest
            (highest valued) version supported by the client.  For this
            version of the specification, the version will be 3.3.
        :return:
        """

        return self._version

    @version.setter
    def version(self, attr: bytes):

        self._version = attr

    @property
    def random(self) -> bytes:
        """
        random
            A client-generated random structure.
        :return:
        """
        _random = self._random
        if not _random:
            _random = bytes(Random())

        return _random

    @random.setter
    def random(self, attr: bytes):

        self._random = attr

    @property
    def session_id(self) -> bytes:
        """
        session_id
            The ID of a session the client wishes to use for this connection.
            This field is empty if no session_id is available, or if the
            client wishes to generate new security parameters.
        :return:
        """
        session_id = self._session_id
        if not session_id:
            session_id = os.urandom(32)

        return session_id

    @session_id.setter
    def session_id(self, attr: bytes):

        self._session_id = attr

    @property
    def cipher_suites(self) -> bytes:
        """
        cipher_suites
            This is a list of the cryptographic options supported by the
            client, with the client's first preference first.  If the session_id
            field is not empty (implying a session resumption request),
            this vector MUST include at least the cipher_suite from that session.
        :return:
        """

        return self._cipher_suites

    @cipher_suites.setter
    def cipher_suites(self, attr: bytes):

        self._cipher_suites = attr

    @property
    def compression_methods(self) -> bytes:
        """
        compression_methods
            This is a list of the compression methods supported by the client,
            sorted by client preference.  If the session_id field is not empty
            (implying a session resumption request), it MUST include the
            compression_method from that session.  This vector MUST contain,
            and all implementations MUST support, CompressionMethod.null.Thus,
            a client and server will always be able to agree on a compression method.
        :return:
        """

        compression_methods = self._compression_methods
        if not compression_methods:
            compression_methods = struct.pack("B", 255)

        return compression_methods

    @compression_methods.setter
    def compression_methods(self, attr: bytes):

        self._compression_methods = attr

    @property
    def extensions(self) -> bytes:
        """
        extensions
            Clients MAY request extended functionality from servers by sending
            data in the extensions field.
        :return:
        """

        return self._extensions

    @extensions.setter
    def extensions(self, attr: bytes):

        self._extensions = attr

    def body(self):

        body = b""
        if self.version:
            body += self.version

        if self.random:
            body += self.random

        if self.session_id:
            body += self.session_id

        if self.cipher_suites:
            body += self.cipher_suites

        if self.compression_methods:
            body += self.compression_methods

        if self.extensions:
            body += self.extensions

        return body

    def length(self) -> bytes:
        """
        uint24 length;             /* bytes in message */
        :return:
        """

        body = self.body()
        return struct.pack("!I", len(body))[1:]

    @property
    def message(self):

        return self.handshake_type + self.length() + self.body()
